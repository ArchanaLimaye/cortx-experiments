## Sidecar Containers 

- ‘A type of multiple container design pattern in kubernetes’. A sidecar is a utility container in a pod that’s loosely coupled to the main application container. Why it must be placed in the same Pod is that it needs to use the same resources being used by the main container. 

- Purpose: Usually to support the main container for some work like logging. 

- Examples: Used as log shippers for logs generated by the main container in a pod. 

- As kubernetes is a highly dynamic and distributed layered environment; in production phase we’ll have many containers scheduling, termination and crash at any point of time. It really becomes a big challenge in itself if any failure occurs as kubernetes is comprised of multiple layers that need to be monitored, each producing different logs. 

- In Kubernetes, when pods are evicted, crashed, deleted, or scheduled on a different node, the logs from the containers are gone. The system cleans up after itself. Therefore, you lose any information about why the anomaly occurred. The transient nature of default logging in Kubernetes makes it crucial to implement a centralized log management solution.  

- A pod typically has a single container in it, but it can also have multiple containers depending on the needs. There are in general three types of multiple container design patterns. 

  1. Side car Pattern 

  2. Ambassador Pattern 

  3. Adapter Pattern 

- Side Car Containers: 

Sidecar container (Auxillary container) helps enhance and assist the main container in a pod. A pod spec which runs the main container and a helper container that does some utility work, but that is not necessarily needed for the main container to work. 

The first layer of logs that can be collected from a Kubernetes cluster are those being generated by your containerized applications. The easiest method for logging containers is to write to the standard output (stdout) and standard error (stderr) streams. 

In simple words; (with reference to pods) 

- Consider a pod manifest example.yaml as below: 
```
apiVersion: v1 

kind: Pod 

metadata: 

name: podwithoutsidecar 

spec: 

containers: 

- name: example 

image: nginx 

args: [/bin/sh, -c, 'while true; do echo $(date); sleep 1; done'] 
```
 
In above pod definition we have just one nginx container, which is our main container that results in running one container logging to stdout. The easiest way to capture container logs is to use stdout and stderr. 

- Now let’s see a pod manifest with sidecar container alongwith the main container. 
```
apiVersion: v1 

kind: Pod 

metadata: 

  name: Podwithsidecar 

spec: 

  containers: 

  - name: example 

    image: nginx 

    args: 

    - /bin/sh 

    - -c 

    - > 

      while true; 

      do 

        echo "$(date)\n" >> /var/log/example.log; 

        sleep 1; 

      done 

    volumeMounts: 

    - name: varlog 

      mountPath: /var/log 

  - name: sidecar 

    image: busybox 

    args: [/bin/sh, -c, 'tail -f /var/log/example.log'] 

    volumeMounts: 

    - name: varlog 

      mountPath: /var/log 

  volumes: 

  - name: varlog 

    emptyDir: {} 
```
Now to apply the spec run;  
```
$ kubectl apply –f Podwithsidecar.yaml 
```
 
As I said the sidecar uses shared network namespace for communication, Let’s Verify without believing in blindly. Run following commands on split master terminal node 
```
Kubectl exec <pod name> -c <name of container> -it bash 

Netstat -nltp 
```
- You can now view the ports which are open. Just run “netcat -l –p 8000” on 1st split terminal. This simply means allowing port 8000 for connection for first container. Now run “netstat -nltp” on 2nd split terminal. You’ll see the sidecar container can also listen on port specified by main container. 

- You can also verify localhost connection and see the connection is working using “telnet localhost” command. 

- We can fetch the logs generated by the sidecar container using below command  
```
Kubectl logs <name of the container> 
```
If you want to access logs of a crashed instance, use  –previous 

- As seen in the above pod manifest we have a sidecar container [busybox] along with main container [nginx] in the same pod named ‘Podwithsidecar’ mounting the same volume and using same network interface. 

Container logs here are written to a file  /var/log/example.log. These logs can either be viewed on each server or collected by a logging agent that pushes them to a central location for log analysis and storage. 

Now the above method seems suitable for simple pod spec, but when thinking about production and at such higher level managing those multiple log files for multiple containers across multiple servers in a cluster needs a new and much more reliable approach and a scalable solution. 


--Ambassador Pattern-- 

This multiple container design pattern connects containers with the outside world. It is a proxy that allows other containers to connect to a port on localhost. 

--Adapter Pattern-- 

The adapter container will inspect the contents of the app's file, does some kind of restructuring and reformat it, and write the correctly formatted output to the location.  

 

 

 

 
